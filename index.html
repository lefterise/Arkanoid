<!DOCTYPE html>
<html>
<head>
<style>
html, body {
  margin: 0;
}
</style>
<script src="geometry.js"></script>
<script>

function roundRect(
	  ctx,
	  x,
	  y,
	  width,
	  height,
	  radius = 5,
	  fill = false,
	  stroke = true
) {
	  if (typeof radius === 'number') {
		radius = {tl: radius, tr: radius, br: radius, bl: radius};
	  } else {
		radius = {...{tl: 0, tr: 0, br: 0, bl: 0}, ...radius};
	  }
	  ctx.beginPath();
	  ctx.moveTo(x + radius.tl, y);
	  ctx.lineTo(x + width - radius.tr, y);
	  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
	  ctx.lineTo(x + width, y + height - radius.br);
	  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
	  ctx.lineTo(x + radius.bl, y + height);
	  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
	  ctx.lineTo(x, y + radius.tl);
	  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
	  ctx.closePath();
	  if (fill) {
		var grd = ctx.createLinearGradient(x+width/2,y, x+width/2,y+height);
		grd.addColorStop(0, "Yellow");		
		grd.addColorStop(0.7, "Orange");
		grd.addColorStop(1, "DarkOrange");
		ctx.fillStyle = grd;
		
		ctx.fill();
	  }
	  if (stroke) {
		ctx.stroke();
	  }
}

function loadSprites(files, completionHandler){
	var numLoaded = 0;
	var numError = 0;
	var sprites = {};
	var checkDone = function(){
		if (numLoaded + numError == files.length){
			completionHandler(sprites, numLoaded, numError);
		}
	}
	for (let file of files){
		let img = new Image();		
		img.src = file + ".png";
		sprites[file] = img;
		img.onload = (e)=> {						
			numLoaded++;			
			checkDone();
		};
		img.onerror = (e) => {						
			numError++;
			checkDone();
		};
	}
}

const Actions = {
	Idle: 0,
	Up: 1,
	Down: 2,
	Fire: 3,
}

class Keyboard{
	constructor(){
		this.delta =  {x:0, y:0};
		this.sensitivity = 0.5;
		this.keysDown = [];
				
		document.addEventListener('keydown', (ev) => {
			if (this.isLeft(ev.keyCode) || this.isRight(ev.keyCode)){
				this.keysDown.push(ev.keyCode);
			}
						
			if (ev.key == "Space" || ev.keyCode == 32){
				
			}
			
			ev.preventDefault();    
			return false;
		}, false);
		
		document.addEventListener('keyup', (ev) => {
			if (this.isLeft(ev.keyCode) || this.isRight(ev.keyCode)){
				this.keysDown = this.keysDown.filter(x => x != ev.keyCode);
			}
			
			ev.preventDefault();
			return false;
		}, false);
	}
	
	isLeft(keyCode){			
		return keyCode == 37 || keyCode == 65;
	}
	
	isRight(keyCode){
		return keyCode == 39 || keyCode == 68;
	}
	
	getDeltaFromPreviousFrame(time){
		if (!this.prevTime){
			this.prevTime = time;
			return {x:0, y:0};
		}
				
		let dx = 0.0;
		if (this.keysDown.length > 0){
		let direction = this.keysDown[this.keysDown.length - 1];
			if (this.isLeft(direction))
				dx = -1.5;
			else if (this.isRight(direction))
				dx = 1.5;
		}
		let dt = time - this.prevTime;
		this.prevTime = time;
		return {x: dx * this.sensitivity * dt, y: this.delta.y * dt};
	}
}

class Touch{	
	constructor(){
		var canvas = document.getElementById("MyCanvas");
		this.previousDelta = {x: 0, y: 0};
		this.deltaMovementFromDown = {x: 0, y: 0};
		
		canvas.addEventListener('touchstart', (e)=>{		
			var touchobj = e.changedTouches[0];
			var rect = canvas.getBoundingClientRect();
			
			let x = touchobj.clientX - rect.left;
			let y = touchobj.clientY - rect.top;
			
			this.previousDelta = {x: 0, y: 0};
			this.touchDown = {x: x, y: y};				
			
			e.preventDefault();
		}, false);
		
		canvas.addEventListener('touchmove', (e)=>{
			if (e.buttons == 0) return;
			var touchobj = e.changedTouches[0];
			var rect = canvas.getBoundingClientRect();
			
			let x = touchobj.clientX - rect.left;
			let y = touchobj.clientY - rect.top;
			
			this.deltaMovementFromDown = {x: x - this.touchDown.x, y: y - this.touchDown.y};
			
			e.preventDefault();
		}, false);
		
		canvas.addEventListener('touchend', (e)=>{
			var touchobj = e.changedTouches[0];
			var rect = canvas.getBoundingClientRect();
			
			let x = touchobj.clientX - rect.left;
			let y = touchobj.clientY - rect.top;
			
			this.touchDown = null;
			this.previousDelta = {x: 0, y: 0};
			this.deltaMovementFromDown = {x: 0, y: 0};
			e.preventDefault();
		}, false);
	}
	
	getDeltaFromPreviousFrame(time){
		let ret = {x: this.deltaMovementFromDown.x - this.previousDelta.x, y: 0.0};
		this.previousDelta = this.deltaMovementFromDown;		
		return ret;
	}
}

class MultiController{
	constructor(a, b){
		this.a = a;
		this.b = b;
	}
	
	getDeltaFromPreviousFrame(time){
		let a = this.a.getDeltaFromPreviousFrame(time);
		let b = this.b.getDeltaFromPreviousFrame(time);
		return {x: a.x + b.x, y: a.y + b.y};
	}
	
}

function ellipse(context, cx, cy, rx, ry){
        context.save(); // save state
        context.beginPath();

        context.translate(cx-rx, cy-ry);
        context.scale(rx, ry);
        context.arc(1, 1, 1, 0, 2 * Math.PI, false);

        context.restore(); // restore to original state
        context.stroke();
}

function ellipse2(context, cx, cy, rx, ry){
        context.save(); // save state

		
        context.beginPath();
        context.translate(cx-rx, cy-ry);
        context.scale(rx, ry);
		
		var grd = context.createRadialGradient(1, 1, 0.4,   1, 1, 1);
		grd.addColorStop(0, "WHITE");
		grd.addColorStop(0.20, "GRAY");
		grd.addColorStop(0.35, "BLACK");
		grd.addColorStop(0.4, "DARKbLUE");
		grd.addColorStop(0.6, "bLUE");
		grd.addColorStop(0.99, "DARKbLUE");
		grd.addColorStop(1, "BLACK");
		context.fillStyle = grd;
		//context.fillRect(0, 0, 150, 100);
        context.arc(1, 1, 1, 0, 2 * Math.PI, false);
		context.fill();
        context.restore(); // restore to original state
       
}



function lineFromPoints(p1, p2){
	let m = (p2.y - p1.y) / (p2.x - p1.x);		
	let c = p1.y - m * p1.x;
	return {m: m, c: c};
}

class Block{
	constructor(x,y,w,h, padding){
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
		
		this.rect = new Rectangle(x,y,w,h, padding);
	}
	

	draw(ctx){
		//roundRect(ctx, this.x, this.y, this.w, this.h, this.h / 3, true, true);
		
		roundRect(ctx, this.x, this.y, this.w, this.h, 0, true, true);
	}
}

class LineTrace{
	constructor(x1,y1, x2,y2, duration){
		this.x1 = x1;
		this.y1 = y1;		
		this.x2 = x2;
		this.y2 = y2;
		this.duration = duration;
	}
	
	update(dt){
		this.duration -= dt;
	}
	
	draw(ctx){
		ctx.beginPath();
		ctx.moveTo(this.x1, this.y1);
		ctx.lineTo(this.x2, this.y2);
		ctx.stroke();
	}
}

class CircleTrace{
	constructor(x,y, r, duration){
		this.x = x;
		this.y = y;		
		this.r = r;
		this.duration = duration;
	}
	
	update(dt){
		this.duration -= dt;
	}
	
	draw(ctx){
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
		ctx.stroke();
	}
}

class Traces{
	constructor(){
		this.traces = [];
	}
	
	addLine(x1,y1, x2,y2, duration){
		let trace = new LineTrace(x1,y1, x2,y2, duration);
		this.traces.push(trace);
	}
	
	addCircle(x,y, r, duration){
		let trace = new CircleTrace(x,y, r, duration);
		this.traces.push(trace);
	}
	
	update(dt){
		for (let trace of this.traces){
			trace.update(dt);
		}
		
		this.traces = this.traces.filter( t=> t.duration > 0);
	}
	
	draw(ctx){
		for (let trace of this.traces){
			trace.draw(ctx);
		}
	}	
}

class Game {

	setSprites(sprites){
		this.sprites = sprites;
	}
	
	start(){
	    var canvas = document.getElementById("MyCanvas");
		var ctx = canvas.getContext("2d");
		
		canvas.addEventListener('contextmenu', function(ev) {
			ev.preventDefault();    
			return false;
		}, false);		
		
		setInterval(()=>window.requestAnimationFrame((time)=>this.draw(ctx, time)), 8);
		
		this.frames = [];
		this.frames.push({x: 191, y: 1, w: 79, h: 28})
		
		this.ball = {x: 20, y:20, w:13, h: 13, dx: 0.25, dy: 0.25, r: 30}; // r: 7
		
		this.paddle ={x:100, y: 540, w:200, h:50};
		this.controller = new MultiController(new Keyboard(), new Touch());
		
		
		this.traces = new Traces();
		
		canvas.addEventListener('mousemove', (e)=>{
			if (e.buttons == 0) return;
			
			var rect = canvas.getBoundingClientRect();
			
			let x = e.clientX - rect.left;
			let y = e.clientY - rect.top;
			
			this.ball.x =x;
			this.ball.y =y;						
		}, false);
		
		
		this.blocks = [];
		
		//for(let r = 0; r < 4; ++r){
//			for(let c = 2; c < 6; ++c){
				//let block = new Block(10 + 98 * c, 50 + 32 * r);				
				//let block = new Block(-100 + 130 * c, 70 + 62 * r, 96, 30, 7);											
			//	this.blocks.push(block);
	//		}
		//}
		
		for(let r = 0; r < 2; ++r){
			for(let c = 0; c < 3; ++c){				
				let block = new Block(150 + 170 * c, 70 + 170 * r, 70, 70, this.ball.r);
				
				this.blocks.push(block);
			}
		}
		
	}

	
	
	checkController(time){
		let delta = this.controller.getDeltaFromPreviousFrame(time);
				
		this.paddle.x += delta.x;		
		this.paddle.y += delta.y;
	}
	
	drawBackground(ctx){
		let sprite = this.sprites["background_exotic"];				
		ctx.drawImage(sprite, 0, 0, 800, 600);
	}
	
	drawLevel(ctx){
		
	}
		
	updateBall(dt, ctx){
		this.traces.update(dt);
	
		let futureBall = {x: this.ball.x + this.ball.dx * dt,
					      y: this.ball.y + this.ball.dy * dt};
		
		if (futureBall.y + this.ball.h / 2.0 > 600){
			futureBall.y = 600 - this.ball.h / 2.0;
			this.ball.dy *= -1;
		}
		
		if (futureBall.y < this.ball.h / 2.0){
			futureBall.y = this.ball.h / 2.0;
			this.ball.dy *= -1;
		}
		
		if (futureBall.x + this.ball.w / 2.0 > 800){
			futureBall.x = 800 - this.ball.w / 2.0;
			this.ball.dx *= -1;
		}
		
		if (futureBall.x < this.ball.w / 2.0){
			futureBall.x = this.ball.w / 2.0;
			this.ball.dx *= -1;
		}
		
		let vector = Vector.create(this.ball);
		
		for(let block of this.blocks){						
			let collision = block.rect.collides(vector, dt, ctx);
			if (collision){
				this.drawBall(ctx);
				
				/*
				this.traces.addCircle(collision.pt.x, collision.pt.y, 2, 1000);				
				
				this.traces.addLine(
					collision.pt.x + 30 * Math.cos(collision.tangent), collision.pt.y + 30 * Math.sin(collision.tangent),
					collision.pt.x - 30 * Math.cos(collision.tangent), collision.pt.y - 30 * Math.sin(collision.tangent),
					1000
				);
				
				this.traces.draw(ctx);
				*/

				let ballSpeed = vector.getMagnitude();
				let incidentAngle = vector.getDirectionAngle();
				let reflectedAngle = 2 * collision.tangent + Math.PI - incidentAngle;

			
				this.ball.dx = -ballSpeed * Math.cos(reflectedAngle);
				this.ball.dy = -ballSpeed * Math.sin(reflectedAngle);
				
				futureBall.x = collision.pt.x + this.ball.dx * (dt - collision.t);
				futureBall.y = collision.pt.y + this.ball.dy * (dt - collision.t);
			}
		}
		this.traces.draw(ctx);

			
		
		let ballRadius = this.ball.r;
		
		let rx = (this.paddle.w) / 2.0 + ballRadius;
		let ry = (this.paddle.h) / 2.0 + ballRadius;					
		
		
		
		let ellip = new Ellipse(this.paddle.x, this.paddle.y, rx, ry);
		let intersectionTime = vector.intersectEllipse(ellip);
		
		if (intersectionTime){
			let intersectionPoint = vector.getPointAt(intersectionTime[0]);
			let polarAngle = ellip.getPolarAngle(intersectionPoint);
			let tangentAngle = ellip.getTangentAngleAtPolarAngle(polarAngle);									
			let incidentAngle = vector.getDirectionAngle();
			let reflectedAngle = 2 * tangentAngle + Math.PI - incidentAngle;
				
			if (intersectionTime[0] > 0){ // if ball will intersect the ellipse at some time in the future
				ctx.beginPath();
				ctx.arc(intersectionPoint.x, intersectionPoint.y, this.ball.r, 0, 2 * Math.PI);
				ctx.stroke();
				
				//Tangent line
				ctx.beginPath();
				ctx.moveTo(intersectionPoint.x + 50 * Math.cos(tangentAngle), intersectionPoint.y + 50 * Math.sin(tangentAngle));
				ctx.lineTo(intersectionPoint.x - 50 * Math.cos(tangentAngle), intersectionPoint.y - 50 * Math.sin(tangentAngle));
				ctx.stroke();
				
				//Normal
				ctx.beginPath();
				ctx.moveTo(intersectionPoint.x, intersectionPoint.y);
				ctx.lineTo(intersectionPoint.x - 50 * Math.cos(tangentAngle + Math.PI / 2.0), intersectionPoint.y - 50 * Math.sin(tangentAngle + Math.PI / 2.0));
				ctx.stroke();
				
				//Projection line
				ctx.beginPath();
				ctx.moveTo(this.ball.x, this.ball.y);
				ctx.lineTo(intersectionPoint.x, intersectionPoint.y);
				ctx.stroke();			

				//reflection
				ctx.beginPath();
				ctx.moveTo(intersectionPoint.x, intersectionPoint.y);
				ctx.lineTo(intersectionPoint.x - 100 * Math.cos(reflectedAngle), intersectionPoint.y - 100 * Math.sin(reflectedAngle));
				ctx.stroke();
			}
		
			if (intersectionTime[0] < 0 && intersectionTime[1] > 0){ //ball already inside paddle
				let closestBorder = Math.abs(intersectionTime[0]) < Math.abs(intersectionTime[1]) ? intersectionTime[0] : intersectionTime[1];
				intersectionPoint = vector.getPointAt(closestBorder);
				polarAngle = ellip.getPolarAngle(intersectionPoint);
				tangentAngle = ellip.getTangentAngleAtPolarAngle(polarAngle);									
				incidentAngle = vector.getDirectionAngle();
				reflectedAngle = 2 * tangentAngle + Math.PI - incidentAngle;
			
				let ballSpeed = vector.getMagnitude();
							
				this.ball.dx = -ballSpeed * Math.cos(reflectedAngle);
				this.ball.dy = -ballSpeed * Math.sin(reflectedAngle);
			
				this.ball.x = intersectionPoint.x + this.ball.dxd;
				this.ball.y = intersectionPoint.y + this.ball.dy;
			} else if (intersectionTime[0] > 0 && intersectionTime[0] <= dt){ //ball has hit paddle in this time slot
				let ballSpeed = vector.getMagnitude();
							
				this.ball.dx = -ballSpeed * Math.cos(reflectedAngle);
				this.ball.dy = -ballSpeed * Math.sin(reflectedAngle);
			
				this.ball.x = intersectionPoint.x + this.ball.dx * (dt - intersectionTime[0]);
				this.ball.y = intersectionPoint.y + this.ball.dy * (dt - intersectionTime[0]);
			}else{
				this.ball.x = futureBall.x;
				this.ball.y = futureBall.y;
			}
		}else {
			this.ball.x = futureBall.x;
			this.ball.y = futureBall.y;
		}
	}
	
	drawBall(ctx){
		let sprite = this.sprites["ball"];
		//ctx.drawImage(sprite, this.ball.x - this.ball.w/2, this.ball.y - this.ball.h/2, this.ball.w, this.ball.h);
		
		var grd = ctx.createRadialGradient(this.ball.x, this.ball.y, 1,   this.ball.x, this.ball.y, this.ball.r);
		grd.addColorStop(0, "WHITE");
		grd.addColorStop(0.99, "GRAY");
		grd.addColorStop(1, "Black");
		ctx.fillStyle = grd;

		ctx.beginPath();
		ctx.arc(this.ball.x, this.ball.y, this.ball.r, 0, 2 * Math.PI);		
		//ctx.strokeStyle = '#00558822';
		ctx.fill();
		ctx.stroke();
		
		//ctx.strokeStyle = '#000000FF';
		
		//ctx.beginPath();
		//ctx.arc(this.ball.x, this.ball.y, 1, 0, 2 * Math.PI);		
		//ctx.stroke();
	}
	
	drawPaddle(ctx){
		let src = this.frames[0];
		let sprite = this.sprites["arcanoids"];
		//ctx.drawImage(sprite, src.x, src.y, src.w, src.h, this.paddle.x  - 79/2, this.paddle.y - 28/2, 79, 28);
		

		ellipse2(ctx, this.paddle.x, this.paddle.y, this.paddle.w/2.0, this.paddle.h/2.0);
		//ellipse(ctx, this.paddle.x, this.paddle.y, (this.paddle.w + this.ball.w)/2.0, (this.paddle.h + this.ball.h)/2.0);
	}
	
	draw(ctx, time){	
		let dt = 0;
		if (this.prevTime){
			dt = time - this.prevTime;
		}
		this.prevTime = time;
		
		this.checkController(time);	
		
		this.drawBackground(ctx);
		this.updateBall(dt,ctx);
		this.drawPaddle(ctx);
		this.drawBall(ctx);
		this.drawLevel(ctx);
		
		for(let block of this.blocks){
			block.draw(ctx);
		}
		
		/*
		ctx.beginPath();
		ctx.arc(40, 40, 20, 0, 2 * Math.PI);
		ctx.stroke();
		
		ctx.beginPath();
		ctx.moveTo(10, 10);
		ctx.lineTo(70, 60);
		ctx.stroke();
				
		let line = this.lineFromPoints({x: 10, y:10}, {x: 70, y:60});
		let circle = {x: 40, y:40, r: 20};
		let pts = intersectLineCircle(line, circle);
	
	
		ctx.beginPath();
		ctx.arc(pts.p1.x, pts.p1.y, 5, 0, 2 * Math.PI);
		ctx.stroke();
		
		ctx.beginPath();
		ctx.arc(pts.p2.x, pts.p2.y, 5, 0, 2 * Math.PI);
		ctx.stroke();
		*/
	}
	
	checkCollision(time){
	
	}
	
}
var game = new Game();

var audio = {
	bounce: new Audio('sounds/bounce.wav'),
	breakBlock: new Audio('sounds/break.wav'),
	complete: new Audio('sounds/complete.wav'),
	launch: new Audio('sounds/launch.wav'),
	loss: new Audio('sounds/loss.wav'),
};
	
loadSprites(["arcanoids", "background_exotic", "ball", "ball_animation", "bullet", "keys", "left_right_arrow", "rainbow", "tiles"], 
	(sprites, succeeded,failed)=>{	
		game.setSprites(sprites);
		game.start();
	}
);


</script>
</head>

<body>
<canvas id="MyCanvas" width="800" height="600" style="border:1px solid #000000; background-color:#000000;"></canvas>
</body>
</html>
