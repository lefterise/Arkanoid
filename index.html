<!DOCTYPE html>
<html>
<head>
<style>
html, body {
  margin: 0;
}
</style>
<script src="geometry.js"></script>
<script src="graphics.js"></script>
<script src="input.js"></script>
<script src="traces.js"></script>
<script>


function setYellowGradientFill(ctx, x,y, width, height){
	var grd = ctx.createLinearGradient(x+width/2,y, x+width/2,y+height);
	grd.addColorStop(0, "Yellow");		
	grd.addColorStop(0.7, "Orange");
	grd.addColorStop(1, "DarkOrange");
	ctx.fillStyle = grd;
}

function setPaddleGradient(ctx){
 	var grd = ctx.createRadialGradient(1, 1, 0.4,   1, 1, 1);
	grd.addColorStop(0, "WHITE");
	grd.addColorStop(0.20, "GRAY");
	grd.addColorStop(0.35, "BLACK");
	grd.addColorStop(0.4, "DARKbLUE");
	grd.addColorStop(0.6, "bLUE");
	grd.addColorStop(0.99, "DARKbLUE");
	grd.addColorStop(1, "BLACK");
	ctx.fillStyle = grd;
}

function loadSprites(files, completionHandler){
	var numLoaded = 0;
	var numError = 0;
	var sprites = {};
	var checkDone = function(){
		if (numLoaded + numError == files.length){
			completionHandler(sprites, numLoaded, numError);
		}
	}
	for (let file of files){
		let img = new Image();		
		img.src = file + ".png";
		sprites[file] = img;
		img.onload = (e)=> {						
			numLoaded++;			
			checkDone();
		};
		img.onerror = (e) => {						
			numError++;
			checkDone();
		};
	}
}

class Block{
	constructor(x,y,w,h, padding){
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
		this.hitpoints = 1;
	
		this.rect = new Rectangle(x,y,w,h, padding);
	}
	
	draw(ctx){
		roundRect(ctx, this.x, this.y, this.w, this.h, this.h / 3, true, true);		
	}
}


class Game {

	setSprites(sprites){
		this.sprites = sprites;
	}
	
	start(){
	    var canvas = document.getElementById("MyCanvas");
		var ctx = canvas.getContext("2d");
		
		canvas.addEventListener('contextmenu', function(ev) {
			ev.preventDefault();    
			return false;
		}, false);		
		
		setInterval(()=>window.requestAnimationFrame((time)=>this.draw(ctx, time)), 8);
		
		this.frames = [];
		this.frames.push({x: 191, y: 1, w: 79, h: 28})
		
		this.ball = {x: 20, y:200, dx: 0.25, dy: 0.25, r: 7}; // r: 30
		
		this.paddle ={x:410, y: 540, w:200, h:50};
		this.controller = new MultiController(new Keyboard(), new Touch());
		
		
		this.traces = new Traces();
		
		canvas.addEventListener('mousemove', (e)=>{
			if (e.buttons == 0) return;
			
			var rect = canvas.getBoundingClientRect();
			
			let x = e.clientX - rect.left;
			let y = e.clientY - rect.top;
			
			this.ball.x =x;
			this.ball.y =y;						
		}, false);
		
		
		this.blocks = [];
		
		this.loadLevel();
	}

	loadLevel(){
		for(let r = 0; r < 4; ++r){
			for(let c = 0; c < 7; ++c){
				let block = new Block(50 + 98 * c, 50 + 32 * r, 96, 30, this.ball.r);
				this.blocks.push(block);
			}
		}
		this.ball = {x: 20, y:200, dx: 0.25, dy: 0.25, r: 7}; // r: 30
	}
	
	
	checkController(time){
		let delta = this.controller.getDeltaFromPreviousFrame(time);
				
		this.paddle.x += delta.x;		
		this.paddle.y += delta.y;
	}
	
	drawBackground(ctx){
		let sprite = this.sprites["background_exotic"];				
		ctx.drawImage(sprite, 0, 0, 800, 600);
	}
	
	addCollisionTrace(x, y, tangent, incidentAngle, reflectedAngle){
		this.traces.addCircle(x, y, 7, 500);				
		
		this.traces.addLine(
			x + 30 * Math.cos(tangent), y + 30 * Math.sin(tangent),
			x - 30 * Math.cos(tangent), y - 30 * Math.sin(tangent),
			500
		);
		
		this.traces.addLine(
			x, y,
			x - 30 * Math.cos(tangent+ Math.PI / 2.0), y - 30 * Math.sin(tangent+ Math.PI / 2.0),
			500
		);
		
		this.traces.addLine(
			x - 50 * Math.cos(incidentAngle), y - 50 * Math.sin(incidentAngle),
			x, y,
			500
		);
		
		this.traces.addLine(
			x - 50 * Math.cos(reflectedAngle), y - 50 * Math.sin(reflectedAngle),
			x, y,
			500
		);
	}
	
	updateBall(dt, ctx){
		this.traces.update(dt);
	
		let futureBall = {x: this.ball.x + this.ball.dx * dt,
					      y: this.ball.y + this.ball.dy * dt};
		
		if (futureBall.y + this.ball.r / 2.0 > 600){
			futureBall.y = 600 - this.ball.r / 2.0;
			this.ball.dy *= -1;
			audio.bounce.play();
		}
		
		if (futureBall.y < this.ball.r / 2.0){
			futureBall.y = this.ball.r / 2.0;
			this.ball.dy *= -1;
			audio.bounce.play();
		}
		
		if (futureBall.x + this.ball.r / 2.0 > 800){
			futureBall.x = 800 - this.ball.r / 2.0;
			this.ball.dx *= -1;
			audio.bounce.play();
		}
		
		if (futureBall.x < this.ball.r / 2.0){
			futureBall.x = this.ball.r / 2.0;
			this.ball.dx *= -1;
			audio.bounce.play();
		}
		
		let vector = Vector.create(this.ball);
		
		for(let block of this.blocks){						
			let collision = block.rect.collides(vector, dt, ctx);
			if (collision){
				this.drawBall(ctx);							

				let ballSpeed = vector.getMagnitude();
				let incidentAngle = vector.getDirectionAngle();
				let reflectedAngle = 2 * collision.tangent + Math.PI - incidentAngle;


				this.addCollisionTrace(collision.pt.x, collision.pt.y, collision.tangent, incidentAngle, reflectedAngle);
			
				this.ball.dx = -ballSpeed * Math.cos(reflectedAngle);
				this.ball.dy = -ballSpeed * Math.sin(reflectedAngle);
				
				futureBall.x = collision.pt.x + this.ball.dx * (dt - collision.t);
				futureBall.y = collision.pt.y + this.ball.dy * (dt - collision.t);
				
				block.hitpoints--;
				
				audio.breakBlock.play();
			}
		}
		
		this.blocks = this.blocks.filter(b => b.hitpoints > 0);
		if (this.blocks.length == 0){
			audio.complete.play();
			this.loadLevel();
			return;
		}
		
		
		let ballRadius = this.ball.r;
		
		let rx = (this.paddle.w) / 2.0 + ballRadius;
		let ry = (this.paddle.h) / 2.0 + ballRadius;					
		
		
		
		let ellip = new Ellipse(this.paddle.x, this.paddle.y, rx, ry);
		let intersectionTime = vector.intersectEllipse(ellip);
		
		if (intersectionTime){
			let intersectionPoint = vector.getPointAt(intersectionTime[0]);
			let polarAngle = ellip.getPolarAngle(intersectionPoint);
			let tangentAngle = ellip.getTangentAngleAtPolarAngle(polarAngle);									
			let incidentAngle = vector.getDirectionAngle();
			let reflectedAngle = 2 * tangentAngle + Math.PI - incidentAngle;
				
			if (intersectionTime[0] > 0){ // if ball will intersect the ellipse at some time in the future
				ctx.beginPath();
				ctx.arc(intersectionPoint.x, intersectionPoint.y, this.ball.r, 0, 2 * Math.PI);
				ctx.stroke();
				
				//Tangent line
				ctx.beginPath();
				ctx.moveTo(intersectionPoint.x + 50 * Math.cos(tangentAngle), intersectionPoint.y + 50 * Math.sin(tangentAngle));
				ctx.lineTo(intersectionPoint.x - 50 * Math.cos(tangentAngle), intersectionPoint.y - 50 * Math.sin(tangentAngle));
				ctx.stroke();
				
				//Normal
				ctx.beginPath();
				ctx.moveTo(intersectionPoint.x, intersectionPoint.y);
				ctx.lineTo(intersectionPoint.x - 50 * Math.cos(tangentAngle + Math.PI / 2.0), intersectionPoint.y - 50 * Math.sin(tangentAngle + Math.PI / 2.0));
				ctx.stroke();
				
				//Projection line
				ctx.beginPath();
				ctx.moveTo(this.ball.x, this.ball.y);
				ctx.lineTo(intersectionPoint.x, intersectionPoint.y);
				ctx.stroke();			

				//reflection
				ctx.beginPath();
				ctx.moveTo(intersectionPoint.x, intersectionPoint.y);
				ctx.lineTo(intersectionPoint.x - 100 * Math.cos(reflectedAngle), intersectionPoint.y - 100 * Math.sin(reflectedAngle));
				ctx.stroke();
			}
		
			if (intersectionTime[0] < 0 && intersectionTime[1] > 0){ //ball already inside paddle
				let closestBorder = Math.abs(intersectionTime[0]) < Math.abs(intersectionTime[1]) ? intersectionTime[0] : intersectionTime[1];
				intersectionPoint = vector.getPointAt(closestBorder);
				polarAngle = ellip.getPolarAngle(intersectionPoint);
				tangentAngle = ellip.getTangentAngleAtPolarAngle(polarAngle);									
				incidentAngle = vector.getDirectionAngle();
				reflectedAngle = 2 * tangentAngle + Math.PI - incidentAngle;
			
				let ballSpeed = vector.getMagnitude();
							
				this.ball.dx = -ballSpeed * Math.cos(reflectedAngle);
				this.ball.dy = -ballSpeed * Math.sin(reflectedAngle);
			
				this.ball.x = intersectionPoint.x + this.ball.dx;
				this.ball.y = intersectionPoint.y + this.ball.dy;
			} else if (intersectionTime[0] > 0 && intersectionTime[0] <= dt){ //ball has hit paddle in this time slot
				let ballSpeed = vector.getMagnitude();
							
				this.ball.dx = -ballSpeed * Math.cos(reflectedAngle);
				this.ball.dy = -ballSpeed * Math.sin(reflectedAngle);
			
				this.ball.x = intersectionPoint.x + this.ball.dx * (dt - intersectionTime[0]);
				this.ball.y = intersectionPoint.y + this.ball.dy * (dt - intersectionTime[0]);
				audio.bounce.play();						
				
				this.addCollisionTrace(intersectionPoint.x, intersectionPoint.y, tangentAngle, incidentAngle, reflectedAngle);
			}else{
				this.ball.x = futureBall.x;
				this.ball.y = futureBall.y;
			}
		}else {
			this.ball.x = futureBall.x;
			this.ball.y = futureBall.y;
		}
		
		this.traces.draw(ctx);
	}
	
	drawBall(ctx){
		let sprite = this.sprites["ball"];
		//ctx.drawImage(sprite, this.ball.x - this.ball.w/2, this.ball.y - this.ball.h/2, this.ball.w, this.ball.h);
		
		var grd = ctx.createRadialGradient(this.ball.x, this.ball.y, 1,   this.ball.x, this.ball.y, this.ball.r);
		grd.addColorStop(0, "WHITE");
		grd.addColorStop(0.99, "GRAY");
		grd.addColorStop(1, "Black");
		ctx.fillStyle = grd;

		ctx.beginPath();
		ctx.arc(this.ball.x, this.ball.y, this.ball.r, 0, 2 * Math.PI);		
		//ctx.strokeStyle = '#00558822';
		ctx.fill();
		ctx.stroke();
		
		//ctx.strokeStyle = '#000000FF';
		
		//Draw ball center
		//ctx.beginPath();
		//ctx.arc(this.ball.x, this.ball.y, 1, 0, 2 * Math.PI);		
		//ctx.stroke();
	}
	
	drawPaddle(ctx){
		let src = this.frames[0];
		let sprite = this.sprites["arcanoids"];
		//ctx.drawImage(sprite, src.x, src.y, src.w, src.h, this.paddle.x  - 79/2, this.paddle.y - 28/2, 79, 28);
		
		setPaddleGradient(ctx);
		ellipse(ctx, this.paddle.x, this.paddle.y, this.paddle.w/2.0, this.paddle.h/2.0, true);		
		//ellipse(ctx, this.paddle.x, this.paddle.y, (this.paddle.w + this.ball.w)/2.0, (this.paddle.h + this.ball.h)/2.0);
	}
	
	draw(ctx, time){	
		let dt = 0;
		if (this.prevTime){
			dt = time - this.prevTime;
		}
		this.prevTime = time;
		
		this.checkController(time);	
		
		this.drawBackground(ctx);
		this.updateBall(dt,ctx);
		this.drawPaddle(ctx);
		this.drawBall(ctx);
		this.drawLevel(ctx);
		
		for(let block of this.blocks){
			setYellowGradientFill(ctx, block.x, block.y, block.w, block.h);
			block.draw(ctx);
		}		
	}
	
	checkCollision(time){
	
	}
	
}
var game = new Game();

var audio = {
	bounce: new Audio('sounds/bounce.wav'),
	breakBlock: new Audio('sounds/break.wav'),
	complete: new Audio('sounds/complete.wav'),
	launch: new Audio('sounds/launch.wav'),
	loss: new Audio('sounds/loss.wav'),
};
	
loadSprites(["arcanoids", "background_exotic", "ball", "ball_animation", "bullet", "keys", "left_right_arrow", "rainbow", "tiles"], 
	(sprites, succeeded,failed)=>{	
		game.setSprites(sprites);
		game.start();
	}
);


</script>
</head>

<body>
<canvas id="MyCanvas" width="800" height="600" style="border:1px solid #000000; background-color:#000000;"></canvas>
</body>
</html>
