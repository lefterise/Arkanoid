<!DOCTYPE html>
<html>
<head>
<style>
html, body {
  margin: 0;
}
</style>
<script src="geometry.js"></script>
<script>

function roundRect(
	  ctx,
	  x,
	  y,
	  width,
	  height,
	  radius = 5,
	  fill = false,
	  stroke = true
) {
	  if (typeof radius === 'number') {
		radius = {tl: radius, tr: radius, br: radius, bl: radius};
	  } else {
		radius = {...{tl: 0, tr: 0, br: 0, bl: 0}, ...radius};
	  }
	  ctx.beginPath();
	  ctx.moveTo(x + radius.tl, y);
	  ctx.lineTo(x + width - radius.tr, y);
	  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
	  ctx.lineTo(x + width, y + height - radius.br);
	  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
	  ctx.lineTo(x + radius.bl, y + height);
	  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
	  ctx.lineTo(x, y + radius.tl);
	  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
	  ctx.closePath();
	  if (fill) {
		var grd = ctx.createLinearGradient(x+width/2,y, x+width/2,y+height);
		grd.addColorStop(0, "Yellow");		
		grd.addColorStop(0.7, "Orange");
		grd.addColorStop(1, "DarkOrange");
		ctx.fillStyle = grd;
		
		ctx.fill();
	  }
	  if (stroke) {
		ctx.stroke();
	  }
}

function loadSprites(files, completionHandler){
	var numLoaded = 0;
	var numError = 0;
	var sprites = {};
	var checkDone = function(){
		if (numLoaded + numError == files.length){
			completionHandler(sprites, numLoaded, numError);
		}
	}
	for (let file of files){
		let img = new Image();		
		img.src = file + ".png";
		sprites[file] = img;
		img.onload = (e)=> {						
			numLoaded++;			
			checkDone();
		};
		img.onerror = (e) => {						
			numError++;
			checkDone();
		};
	}
}

const Actions = {
	Idle: 0,
	Up: 1,
	Down: 2,
	Fire: 3,
}

class Keyboard{
	constructor(){
		this.delta =  {x:0, y:0};
		this.sensitivity = 0.5;
		this.keysDown = [];
				
		document.addEventListener('keydown', (ev) => {
			if (this.isLeft(ev.keyCode) || this.isRight(ev.keyCode)){
				this.keysDown.push(ev.keyCode);
			}
						
			if (ev.key == "Space" || ev.keyCode == 32){
				
			}
			
			ev.preventDefault();    
			return false;
		}, false);
		
		document.addEventListener('keyup', (ev) => {
			if (this.isLeft(ev.keyCode) || this.isRight(ev.keyCode)){
				this.keysDown = this.keysDown.filter(x => x != ev.keyCode);
			}
			
			ev.preventDefault();
			return false;
		}, false);
	}
	
	isLeft(keyCode){			
		return keyCode == 37 || keyCode == 65;
	}
	
	isRight(keyCode){
		return keyCode == 39 || keyCode == 68;
	}
	
	getDeltaFromPreviousFrame(time){
		if (!this.prevTime){
			this.prevTime = time;
			return {x:0, y:0};
		}
				
		let dx = 0.0;
		if (this.keysDown.length > 0){
		let direction = this.keysDown[this.keysDown.length - 1];
			if (this.isLeft(direction))
				dx = -1.5;
			else if (this.isRight(direction))
				dx = 1.5;
		}
		let dt = time - this.prevTime;
		this.prevTime = time;
		return {x: dx * this.sensitivity * dt, y: this.delta.y * dt};
	}
}

class Touch{	
	constructor(){
		var canvas = document.getElementById("MyCanvas");
		this.previousDelta = {x: 0, y: 0};
		this.deltaMovementFromDown = {x: 0, y: 0};
		
		canvas.addEventListener('touchstart', (e)=>{		
			var touchobj = e.changedTouches[0];
			var rect = canvas.getBoundingClientRect();
			
			let x = touchobj.clientX - rect.left;
			let y = touchobj.clientY - rect.top;
			
			this.previousDelta = {x: 0, y: 0};
			this.touchDown = {x: x, y: y};				
			
			e.preventDefault();
		}, false);
		
		canvas.addEventListener('touchmove', (e)=>{
			if (e.buttons == 0) return;
			var touchobj = e.changedTouches[0];
			var rect = canvas.getBoundingClientRect();
			
			let x = touchobj.clientX - rect.left;
			let y = touchobj.clientY - rect.top;
			
			this.deltaMovementFromDown = {x: x - this.touchDown.x, y: y - this.touchDown.y};
			
			e.preventDefault();
		}, false);
		
		canvas.addEventListener('touchend', (e)=>{
			var touchobj = e.changedTouches[0];
			var rect = canvas.getBoundingClientRect();
			
			let x = touchobj.clientX - rect.left;
			let y = touchobj.clientY - rect.top;
			
			this.touchDown = null;
			this.previousDelta = {x: 0, y: 0};
			this.deltaMovementFromDown = {x: 0, y: 0};
			e.preventDefault();
		}, false);
	}
	
	getDeltaFromPreviousFrame(time){
		let ret = {x: this.deltaMovementFromDown.x - this.previousDelta.x, y: 0.0};
		this.previousDelta = this.deltaMovementFromDown;		
		return ret;
	}
}

class MultiController{
	constructor(a, b){
		this.a = a;
		this.b = b;
	}
	
	getDeltaFromPreviousFrame(time){
		let a = this.a.getDeltaFromPreviousFrame(time);
		let b = this.b.getDeltaFromPreviousFrame(time);
		return {x: a.x + b.x, y: a.y + b.y};
	}
	
}

function ellipse(context, cx, cy, rx, ry){
        context.save(); // save state
        context.beginPath();

        context.translate(cx-rx, cy-ry);
        context.scale(rx, ry);
        context.arc(1, 1, 1, 0, 2 * Math.PI, false);

        context.restore(); // restore to original state
        context.stroke();
}

function ellipse2(context, cx, cy, rx, ry){
        context.save(); // save state

		
        context.beginPath();
        context.translate(cx-rx, cy-ry);
        context.scale(rx, ry);
		
		var grd = context.createRadialGradient(1, 1, 0.4,   1, 1, 1);
		grd.addColorStop(0, "WHITE");
		grd.addColorStop(0.20, "GRAY");
		grd.addColorStop(0.35, "BLACK");
		grd.addColorStop(0.4, "DARKbLUE");
		grd.addColorStop(0.6, "bLUE");
		grd.addColorStop(0.99, "DARKbLUE");
		grd.addColorStop(1, "BLACK");
		context.fillStyle = grd;
		//context.fillRect(0, 0, 150, 100);
        context.arc(1, 1, 1, 0, 2 * Math.PI, false);
		context.fill();
        context.restore(); // restore to original state
       
}



function lineFromPoints(p1, p2){
	let m = (p2.y - p1.y) / (p2.x - p1.x);		
	let c = p1.y - m * p1.x;
	return {m: m, c: c};
}

class Block{
	constructor(x,y){
		this.x = x;
		this.y = y;
		this.w = 96;
		this.h = 30;
	}
	

	collides(ball, dt){
		let m = (ball.dy) / (ball.dx);		
		let c = ball.y - m * ball.x;
		
		let ybottom = this.y + this.h + ball.r;		
		let xbottom = (ybottom - c) / m;
		
		if (ball.y + ball.dy * dt <= ybottom && ybottom <= ball.y && this.x < xbottom && xbottom < this.x + this.w){
			return {x: xbottom, y: ybottom, direction: 'bottom'};
		}
		
		let ytop = this.y - ball.r;		
		let xtop = (ytop - c) / m;
		
		if (ball.y + ball.dy * dt >= ytop && ytop >= ball.y && this.x < xtop && xtop < this.x + this.w){
			return {x: xtop, y: ytop, direction: 'top'};
		}

		let xleft = this.x - ball.r;		
		let yleft = m * xleft + c;
		
		if (ball.x + ball.dx * dt >= xleft && xleft >= ball.x && this.y < yleft && yleft < this.y + this.h){
			return {x: xleft, y: yleft, direction: 'left'};
		}

		let xright = this.x + this.w + ball.r;		
		let yright = m * xright + c;
		
		if (ball.x + ball.dx * dt <= xright && xright <= ball.x && this.y < yright && yright < this.y + this.h){
			return {x: xright, y: yright, direction: 'right'};
		}
	}	
	
	draw(ctx){
		roundRect(ctx, this.x, this.y, this.w, this.h, this.h / 3, true, true);
	}
}

class Game {

	setSprites(sprites){
		this.sprites = sprites;
	}
	
	start(){
	    var canvas = document.getElementById("MyCanvas");
		var ctx = canvas.getContext("2d");
		
		canvas.addEventListener('contextmenu', function(ev) {
			ev.preventDefault();    
			return false;
		}, false);		
		
		setInterval(()=>window.requestAnimationFrame((time)=>this.draw(ctx, time)), 8);
		
		this.frames = [];
		this.frames.push({x: 191, y: 1, w: 79, h: 28})
		
		this.ball = {x: 20, y:20, w:13, h: 13, dx: 0.25, dy: 0.25, r: 7};
		
		this.paddle ={x:100, y: 540, w:200, h:50};
		this.controller = new MultiController(new Keyboard(), new Touch());
		
		
		canvas.addEventListener('mousemove', (e)=>{
			if (e.buttons == 0) return;
			
			var rect = canvas.getBoundingClientRect();
			
			let x = e.clientX - rect.left;
			let y = e.clientY - rect.top;
			
			this.ball.x =x;
			this.ball.y =y;						
		}, false);
		
		
		this.blocks = [];
		
		for(let r = 0; r < 4; ++r){
			for(let c = 2; c < 6; ++c){
				let block = new Block(10 + 98 * c, 50 + 32 * r);
				this.blocks.push(block);
			}
		}
	}

	
	
	checkController(time){
		let delta = this.controller.getDeltaFromPreviousFrame(time);
				
		this.paddle.x += delta.x;		
		this.paddle.y += delta.y;
	}
	
	drawBackground(ctx){
		let sprite = this.sprites["background_exotic"];				
		ctx.drawImage(sprite, 0, 0, 800, 600);
	}
	
	drawLevel(ctx){
		
	}
		
	updateBall(dt, ctx){
		let futureBall = {x: this.ball.x + this.ball.dx * dt,
					      y: this.ball.y + this.ball.dy * dt};
		
		if (futureBall.y + this.ball.h / 2.0 > 600){
			futureBall.y = 600 - this.ball.h / 2.0;
			this.ball.dy *= -1;
		}
		
		if (futureBall.y < this.ball.h / 2.0){
			futureBall.y = this.ball.h / 2.0;
			this.ball.dy *= -1;
		}
		
		if (futureBall.x + this.ball.w / 2.0 > 800){
			futureBall.x = 800 - this.ball.w / 2.0;
			this.ball.dx *= -1;
		}
		
		if (futureBall.x < this.ball.w / 2.0){
			futureBall.x = this.ball.w / 2.0;
			this.ball.dx *= -1;
		}
		
		for(let block of this.blocks){			
			let collision = block.collides(this.ball, dt);
			if (collision){
				this.drawBall(ctx);
				
				if (collision.direction == 'top' ||collision.direction == 'bottom'){
					this.ball.x = collision.x-this.ball.dy;
					this.ball.y = collision.y-this.ball.dy;
					this.ball.dy = -this.ball.dy;
				}else {
					this.ball.x = collision.x-this.ball.dx;
					this.ball.y = collision.y-this.ball.dx;
					this.ball.dx = -this.ball.dx;
				}
			}
		}
		

			
		
		let ballRadius = 7;
		
		let rx = (this.paddle.w) / 2.0 + ballRadius;
		let ry = (this.paddle.h) / 2.0 + ballRadius;					
		
		
		let vector = Vector.create(this.ball);
		let ellip = new Ellipse(this.paddle.x, this.paddle.y, rx, ry);
		let intersectionTime = vector.intersectEllipse(ellip);
		
		if (intersectionTime && intersectionTime[0] > 0){			
			let intersectionPoint = vector.getPointAt(intersectionTime[0]);
			let polarAngle = ellip.getPolarAngle(intersectionPoint);
			let tangentAngle = ellip.getTangentAngleAtPolarAngle(polarAngle);
						
			
			let incidentAngle = vector.getDirectionAngle();
			let reflectedAngle = 2 * tangentAngle + Math.PI - incidentAngle;
			
						
			ctx.beginPath();
			ctx.arc(intersectionPoint.x, intersectionPoint.y, 7, 0, 2 * Math.PI);			
			ctx.stroke();
			
			//Tangent line
			ctx.beginPath();
			ctx.moveTo(intersectionPoint.x + 50 * Math.cos(tangentAngle), intersectionPoint.y + 50 * Math.sin(tangentAngle));
			ctx.lineTo(intersectionPoint.x - 50 * Math.cos(tangentAngle), intersectionPoint.y - 50 * Math.sin(tangentAngle));
			ctx.stroke();
			
			//Normal
			ctx.beginPath();
			ctx.moveTo(intersectionPoint.x, intersectionPoint.y);
			ctx.lineTo(intersectionPoint.x - 50 * Math.cos(tangentAngle + Math.PI / 2.0), intersectionPoint.y - 50 * Math.sin(tangentAngle + Math.PI / 2.0));
			ctx.stroke();
			
			//Projection line
			ctx.beginPath();
			ctx.moveTo(this.ball.x, this.ball.y);
			ctx.lineTo(intersectionPoint.x, intersectionPoint.y);
			ctx.stroke();			

			//reflection
			ctx.beginPath();
			ctx.moveTo(intersectionPoint.x, intersectionPoint.y);
			ctx.lineTo(intersectionPoint.x - 100 * Math.cos(reflectedAngle), intersectionPoint.y - 100 * Math.sin(reflectedAngle));
			ctx.stroke();
					
			
			if (intersectionTime[0] < dt && dt < intersectionTime[1]){
		
				let ballSpeed = vector.getMagnitude();
								
				this.ball.dx = -ballSpeed * Math.cos(reflectedAngle);
				this.ball.dy = -ballSpeed * Math.sin(reflectedAngle);
				
				this.ball.x = intersectionPoint.x + this.ball.dx;
				this.ball.y = intersectionPoint.y - this.ball.dy;
			}else{
				this.ball.x = futureBall.x;
				this.ball.y = futureBall.y;
			}
			
		}else{
			/*
			ctx.beginPath();
			ctx.moveTo(this.ball.x, this.ball.y);
			ctx.setLineDash([5, 15]);
			ctx.lineTo(this.ball.x + this.ball.dx * 10000, this.ball.y + this.ball.dy * 10000);
			ctx.stroke();
			ctx.setLineDash([]);
			*/
			this.ball.x = futureBall.x;
			this.ball.y = futureBall.y;
		}
	}
	
	drawBall(ctx){
		let sprite = this.sprites["ball"];
		//ctx.drawImage(sprite, this.ball.x - this.ball.w/2, this.ball.y - this.ball.h/2, this.ball.w, this.ball.h);
		
		var grd = ctx.createRadialGradient(this.ball.x, this.ball.y, 1,   this.ball.x, this.ball.y, 7);
		grd.addColorStop(0, "WHITE");
		grd.addColorStop(0.99, "GRAY");
		grd.addColorStop(1, "Black");
		ctx.fillStyle = grd;

		ctx.beginPath();
		ctx.arc(this.ball.x, this.ball.y, 7, 0, 2 * Math.PI);
		ctx.fill();
		ctx.stroke();
	}
	
	drawPaddle(ctx){
		let src = this.frames[0];
		let sprite = this.sprites["arcanoids"];
		//ctx.drawImage(sprite, src.x, src.y, src.w, src.h, this.paddle.x  - 79/2, this.paddle.y - 28/2, 79, 28);
		

		ellipse2(ctx, this.paddle.x, this.paddle.y, this.paddle.w/2.0, this.paddle.h/2.0);
		//ellipse(ctx, this.paddle.x, this.paddle.y, (this.paddle.w + this.ball.w)/2.0, (this.paddle.h + this.ball.h)/2.0);
	}
	
	draw(ctx, time){	
		let dt = 0;
		if (this.prevTime){
			dt = time - this.prevTime;
		}
		this.prevTime = time;
		
		this.checkController(time);	
		
		this.drawBackground(ctx);
		this.updateBall(dt,ctx);
		this.drawPaddle(ctx);
		this.drawBall(ctx);
		this.drawLevel(ctx);
		
		for(let block of this.blocks){
			block.draw(ctx);
		}
		
		/*
		ctx.beginPath();
		ctx.arc(40, 40, 20, 0, 2 * Math.PI);
		ctx.stroke();
		
		ctx.beginPath();
		ctx.moveTo(10, 10);
		ctx.lineTo(70, 60);
		ctx.stroke();
				
		let line = this.lineFromPoints({x: 10, y:10}, {x: 70, y:60});
		let circle = {x: 40, y:40, r: 20};
		let pts = intersectLineCircle(line, circle);
	
	
		ctx.beginPath();
		ctx.arc(pts.p1.x, pts.p1.y, 5, 0, 2 * Math.PI);
		ctx.stroke();
		
		ctx.beginPath();
		ctx.arc(pts.p2.x, pts.p2.y, 5, 0, 2 * Math.PI);
		ctx.stroke();
		*/
	}
	
	checkCollision(time){
	
	}
	
}
var game = new Game();

var audio = {
	bounce: new Audio('sounds/bounce.wav'),
	breakBlock: new Audio('sounds/break.wav'),
	complete: new Audio('sounds/complete.wav'),
	launch: new Audio('sounds/launch.wav'),
	loss: new Audio('sounds/loss.wav'),
};
	
loadSprites(["arcanoids", "background_exotic", "ball", "ball_animation", "bullet", "keys", "left_right_arrow", "rainbow", "tiles"], 
	(sprites, succeeded,failed)=>{	
		game.setSprites(sprites);
		game.start();
	}
);


</script>
</head>

<body>
<canvas id="MyCanvas" width="800" height="600" style="border:1px solid #000000; background-color:#000000;"></canvas>
</body>
</html>
